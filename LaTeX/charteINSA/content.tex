\sectionnn{Introduction}

\paragraph{}
Un moteur graphique est un programme qui permet de convertir un ensemble de coordonnées tridimensionnel en un rendu bidimensionnel (c'est-à-dire d'un ensemble de points à l'image affiché sur un écran par exemple).

\paragraph{}
Les moteur 3D ont divers domaines d'applications : l'affichage d'une simulation, d'une modélisation, les films d'animation, ou plus communément les jeux vidéo...

\paragraph{}
Dans les jeux vidéo, notamment, il existe deux principaux moteurs graphiques (unreal engine et Unity), qui sont assez complets et faciles à prendre en main ce qui permet aux développeurs d'avoir accès à un moteur graphique sans en comprendre l'aspect mathématique. Il est donc intéressant de recoder un moteur graphique depuis la base afin d'en comprendre tous les aspects.

\paragraph{}
Pour développer ce moteur graphique, nous avons dû nous informer : comprendre comment marche le moteur graphique et à notre niveau de recréer certaines fonctionnalités, comprendre l'aspect mathématique et enfin de le coder.

\paragraph{}
Nous sommes arrivés à un certains résultats malgré certaines difficultés que nous aborderons.

\newpage

\section{Début du projet : recherche et organisation}
\subsection{Choix du language}
\paragraph{}
Lorsque le projet nous a été présenté, on nous a conseillé de nous tourner vers le python, car facile en prendre en main et des librairies était déjà existante pour faciliter le code. Nonobstant, connaissant déjà le langage python, nous voulions faire un choix différent, pour essayer de découvrir ce sujet d'un autre point de vue et d'apprendre un nouveau langage.

\paragraph{}
Dans un premier temps, nous nous sommes tournés vers le C++, mais on s'est vite rendu compte qu'il existait peu de librairies 2D, et que les librairies existantes faisait déjà office de librairies 3D, ce qui est assez regrettable.

\paragraph{}
Nous sommes donc partie sur le javascript(JS), un langage qui est assez courant, et que l'on peux intégrer à une page web.

\subsection{Appréhensions et attentes}
\paragraph{}
Les moteurs graphiques d'aujourd'hui étant assez complet, nous ne pouvions pas faire quelque chose d'aussi élaboré, c'est pourquoi nous avons dû faire des choix sur ce que nous souhaitions intégrer.

\paragraph{}
Notre objectif était d'avoir un moteur 3D qui tourne, avec des commandes simples pour se déplacer dans l'espace, et la possibilité d'importer un objet modélisé en 3D depuis un logiciel externe dans notre moteur graphique.

\paragraph{}
Ce projet était notre premier projet mélant programmation et mathématiques, qui plus est, dans un nouveau langage.
En sachant cela, nous avions peur de viser un peu trop haut et de ne pas être pas capable de fournir un travail abouti. Nous avions également peur d'être bloqué sur des erreurs de langage sans outils pour les corriger puisque notre moteur graphique était dans un langage différent de celui des autres groupes.

\subsection{Connaissances à mobiliser}
\paragraph{}
Codant dans un nouveau langage : le javascript, nous avons dû apprendre les bases afin d'être capable de le manipuler.
Nous avons également dû nous familiariser avec l'aspect mathématique du fonctionnement du moteur graphique, pour cela, nous nous sommes renseignées sur internet et avons reçu l'aide de notre encadrant qui nous a également fourni un livre sur le sujet.

\paragraph{}
Enfin, par soucis d'organisation, il a fallu réfléchir à une manière de gérer le code, nous nous sommes donc tourné vers git afin d'avoir une trace de l'historique du code et pouvoir travailler sur plusieurs versions du code en parallèle.

\newpage





\section{Explication générique du moteur graphique (math et dessin only)}


\section{Construction du moteur graphique (code et fonction, déroulé du projet)}
\paragraph{}
Pour commencer, on devait partir de rien et tout reconstruire, nous avons donc commencé par nous armer de quelques outils mathématiques comme le produit scalaire ou le produit vectoriel.

\begin{code}
    \begin{minted}[linenos,frame=single]{js}
        //produit scalaire 
        function dotProduct(u, v) {
          return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
        }
        
        // produit vectoriel en dimension 3
        function crossProduct(u, v) {
          const x = u[1] * v[2] - u[2] * v[1];
          const y = u[2] * v[0] - u[0] * v[2];
          const z = u[0] * v[1] - u[1] * v[0];
          return [x, y, z];
        }
    \end{minted}
    \captionof{listing}{Exemple de fonctions que nous avons recodés}
    
    \label{code:crossproduct_and_dotproduct}
\end{code}

\paragraph{}
Il a fallu aussi definir les variables, en utiliser le moins possible pour que tout soit lié et naturel, nous avons donc pour cela besoin:
- de la position de la caméra et son angle pour pouvoir la faire bouger et donc bouger les objets
- de la position de l'écran  , qui est face à la camera et qui permet de faire les projection
De cela nous pouvions utiliser ces trois jeux de variables pour créer tout ce dont nous allons avoir besoin , nos bases , la distance à l'écran , et les projections.
 Comme nous ne savions pas du tout comment faire nous avons voulu commencer par la base , afficher une forme en 2D. Jusque là c'etait simple puisque Javascript dispose de méthode native pour gérer du 2D.
 Ensuite on est passé sur du 3D avec beaucoup de travail.
 Il fallait créer la fonction de projection, et donc choisir la projection que l'on voulait. On a opté pour une projection en perspective car la plus logique et réaliste.
 On a donc cherché et vérifé la formule  (photo des fonctions), pour avoir une fonction projection optionnelle.
 Ensuite il y a tout ce qui est rendu: il a fallu savoir comment tracer et representer cette projection. Nous avons opté par la méthode fill, qui a ses avantages et inconveniants. Les avantages sont que cette méthode est très simple à utiliser, visuelle dans le code, et grâce à elle on pouvait modéliser des formes sur un autre logiciel et les importer (nous y reviendrons plus  tard); cependant il empeche certains corrections, comme la mise en place efficace d'ombre sur une face.
 Pour rendre ces objets sur l'écran nous avons opté de les découper en triangle ce qui rendait plus facile leur projection une à une.
 Grâce à cela , nous avons pu faire un moteur graphique simple et efficace qui peut, sans être trop compliqué , afficher des objets 3D en 2D.
\section{Ou on en est arrivé}
 A la fin de notre projet , nous sommes arrivés à un moteur qui marche certes mais qui ne completait pas toutes nos attentes, mais qui a la particularité de pouvoir avoir une petite utilité.
 En effet , nous pouvons grâce à real intgine , afficher des formes 3D et les faire bouger , que ce soit pas translation ou rotation .
 De plus nous pouvons importer une forme modélisé et l'afficher ce qui est pratique
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{graphics/flux_data.jpg}
  \caption{Flux de données des objets importés}
  \label{structure_capital}
\end{figure}

Cependant la version que nous avons fait contient beaucoup de défauts et est très simpliste. En effet , nous avons remarqué plusieurs défauts inhérents au choix que nous avons fait dans notre développement , comme le fait d'utiliser la méthode fill pour tracer nos formes , font ue on ne peut gerer que les contours et le centre d'une face. Notre moteur graphique créé donc des situations non réalistes. Par exemple, on a le fait qu'il ne faut pas afficher les faces derrieres soit, donc avec fill nous avons caché les faces donc le centre est derriere nous. Cependant il existe la situation où ,lorsqu'il y a une face qui tourne et passe un peu derriere la camera, si on s'arrete à un angle où le centre de cette face est derriere nous mais il reste une partie devant nous, cette face n'est pas affichée. Cela est d'autant plus un défaut que lorsque l'on fait cela avec un solide, il y a donc une face qui disparait , et il s'ouvre devant nous.

\section{Difficultés}
Comme dis précédemment , il y a eu beaucoup de difficultes lors de ce projet , du aux contraintes que l'on avait et au manque d'expérience. Premierement, vu que l'on codait en Javascript, on affichait sur une page web , et donc on devait utiliser la console. A cause de cela le debugging devenait tres compliqué.
De plus il y a eu le probeleme d'ordre d'affichage des face qui a créé des bugs, car comme il n'y avait pas d'ordre précisé, il y a des faces qui ne s'affichent pas dans le solide fermé.
Un autre probleme rencontré est le fait  que nous avons mal géré le temps , qui parraissait aussi un peu cours pour l'ampleur du projet. Comme nous partions de zéro, il était compliqué d'avoir une bonne organisation du temps car nous ne savions pas combien de temps une tâche allait durer, comme la fonction faceorder décrit au dessus ,où nous croyions que cela pouvait être  
fait en quelques jours, mais finalement cela a prit plusieurs semaines à cause de la non connaissance du langage ou des problèmes de debbuggage, qui est devenu impossible sur la fin. A cause de tout cela, cette fonction unique nous a pris plusieurs semaines et n'est pas totalement implémenté à cause de l'impossibilité de debbugger.
A cause de toutes ces problemes nous avons eu beaucoup de difficultés, mais au final nous avons créér un moteur graphique mathématique qui est intérractif et fonctionnel, malgré quelques défauts.

\sectionnn{Conclusion}

En conclusion, notre projet de construction de moteur graphique a été une expérience passionnante et enrichissante. Bien que nous n'ayons pas atteint tous les objectifs initialement fixés, nous avons tout de même réalisé des avancées significatives et avons réussi à créer quelque chose que nous aimons et dont nous sommes fiers.

Le processus de développement de ce moteur graphique nous a permis d'explorer de nouvelles idées, d'apprendre de nouvelles compétences et de repousser nos limites. Les obstacles et les défis rencontrés en cours de route nous ont permis d'acquérir une précieuse expérience et de mieux comprendre les complexités du développement d'un moteur graphique.

Il est important de reconnaître que la réalisation d'un projet aussi ambitieux que la construction d'un moteur graphique nécessite souvent plus de temps et de ressources que prévu initialement. Cependant, cela ne diminue en rien les accomplissements et les apprentissages que nous avons acquis tout au long de ce parcours.

En fin de compte, notre projet de construction de moteur graphique a été une expérience précieuse et stimulante. Nous avons développé des compétences techniques, renforcé notre esprit d'équipe à deux et découvert de nouvelles perspectives de nouvelles applications de notre savoir faire et un nouveau langage.. Nous sommes fiers de notre travail et sommes content d'avoir eu cette expérience pour l'avenir, notament dans l'aspect gestion de projet, où nous gererons mieux le temps et les objectifs pour mener à bien un travail d'équipe.
